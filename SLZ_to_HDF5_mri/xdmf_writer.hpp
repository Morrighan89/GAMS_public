#ifndef writeXdmf_HEADER
#define writeXdmf_HEADER

#include <iostream>
#include <fstream>
#include <math.h>
#include <string>
#include "Mesh.hpp"
#include "slz.hpp"
#include "precision.hpp"
//this is a class to write the xdmf file complementing the hdf5 file obtained from our simulation
namespace slzToHdf5
{
	class writeXdmf{
	public:
		void postProcess(real_t& time);
		writeXdmf(std::string& M_CaseName, slzToHdf5::MeshData* mesh, slzToHdf5::SlzData*  slz,int withMean, int withMat);
	
		
		MeshData* ptrMesh;
		SlzData* ptrSlz;
		
		void writeInitXdmf();
		void writeToXdmf(int& time, int& MeshType);
		void writeCloseLinesXdmf();
		void removeCloseLinesXdmf();
		

		void writeTopology(std::ofstream& xdmf, int& MeshType);
		void writeStructuredTopology(std::ofstream& xdmf, int& MeshType);
		void writeGeometry(std::ofstream& xdmf);
		void writeAttributes(std::ofstream& xdmf, std::string qtyName, std::string qtyType, std::string qtyCenter, int rowx, int rowy, int rowz, int column);
		void writeStaticAttributes(std::ofstream& xdmf, std::string qtyName, std::string qtyType, std::string qtyCenter, int rowx, int rowy, int rowz, int column);

		
		void writeVariable();
		void writeScalar();
		void writeVector();
		


		std::ofstream     M_xdmf;
		int				  M_withMean;
		int               M_withMat;
		const std::string M_closingLines;
		std::streampos    M_closingLinesPosition;
		std::string       M_outputFileName;
		std::string       M_H5FileName;
		std::string       M_CaseName;

	};
	//Constructors
	writeXdmf::writeXdmf(std::string& Name, slzToHdf5::MeshData*  mesh, slzToHdf5::SlzData*  slz, int withMean, int withMat) :

		         M_closingLines("\n    </Grid>\n\n  </Domain>\n</Xdmf>\n"),
		         M_outputFileName("noninitialisedFileName"),
				 M_CaseName(Name),
				 ptrMesh(mesh),
				 ptrSlz(slz),
				 M_withMean(withMean),
				 M_withMat(withMat)

		 {
		 }

	//Methods
	void writeXdmf::postProcess(real_t& time)
		 {
		     
			M_outputFileName = this->M_CaseName + ".xmf";
			M_H5FileName = this->M_CaseName + ".h5";
			
				         // write empty xdmf file
				         writeInitXdmf();
				             
				         
			     }

	//Protected Methods

	void writeXdmf::writeInitXdmf()
		 {
		    
			         M_xdmf.open((M_outputFileName).c_str(), std::ios_base::out);
			
				         M_xdmf << "<?xml version=\"1.0\" ?>\n"
				 << "<!DOCTYPE Xdmf SYSTEM \""
				 << this->M_CaseName
				 << ".xdmf\" [\n"
				 << "<!ENTITY DataFile \""
				 << this->M_CaseName
				 << ".h5\">\n"
				 << "]>\n"
				 << "<!-- "
				 << this->M_CaseName
				 << ".h5 is generated by Sally -->\n"
				 << "<Xdmf>\n"
				 << "  <Domain Name=\""
				 << this->M_CaseName
				 << "\">\n"
				 << "    <Grid Name=\""
				 << this->M_CaseName
				 << "Grid\" GridType=\"Collection\" CollectionType=\"Temporal\">\n"
				 << "\n";
			
				         writeCloseLinesXdmf();
			     
		 }
	
		 
	void writeXdmf::writeToXdmf(int& time, int& MeshType)
		 {
		     /*
				         strategy: write the topology,
				         <Topology
				         Type="Tetrahedron"
				         NumberOfElements="183"
				         BaseOffset="1">
				         <DataStructure Format="HDF"
				         Dimensions="602  4" ???
				         DataType="Int"
				         Precision="8">
				         &DataFile;:/Connections/Values
				         </DataStructure>
				         </Topology>
				         and then the geometry
				         <Geometry Type="X_Y_Z">
				         <DataStructure Format="HDF"
				         Dimensions="183"
				         DataType="Float"
				         Precision="8">
				         &DataFile;:/PointsX/Values
				         </DataStructure>
				         <DataStructure Format="HDF"
				         Dimensions="183"
				         DataType="Float"
				         Precision="8">
				         &DataFile;:/PointsY/Values
				         </DataStructure>
				         <DataStructure Format="HDF"
				         Dimensions="183"
				         DataType="Float"
				         Precision="8">
				         &DataFile;:/PointsY/Values
				         </DataStructure>
				         </Geometry>
				  
				  
				         In this aim we create
				         two Epetra_IntVector, one with a repeated map and the second with a unique map
				         two Epetra_MultiVector, one with a repeated map and the second with a unique map
				  
				         The Int vectors are for the connections, the Real ones for the Vertices
				       */
				  
				       
			         removeCloseLinesXdmf();
			
				         // write grid with time, topology, geometry and attributes
				         // NOTE: The first line (<!-- Time t Iteration i -->) is used in function importFromTime.
				         //       Check compatibility after any change on it!
				         M_xdmf <<
							 "<!-- Time " << time << " Iteration " << time << " -->\n" <<
				             "    <Grid Name=\"Mesh " << time << "\">\n" <<
				             "      <Time TimeType=\"Single\" Value=\"" << time << "\" />\n";
			         writeStructuredTopology(M_xdmf,MeshType);
			         writeGeometry(M_xdmf);
					 writeStaticAttributes(M_xdmf, "MatCodes", "Scalar", "Cell", this->ptrSlz->M_intNx, this->ptrSlz->M_intNy, this->ptrSlz->M_intNz, (int)1);
					 writeAttributes(M_xdmf, "MM", "Vector", "Cell", this->ptrSlz->M_intNx, this->ptrSlz->M_intNy, this->ptrSlz->M_intNz, (int)3);
					 writeAttributes(M_xdmf, "B_Field", "Vector", "Cell", this->ptrSlz->M_intNx, this->ptrSlz->M_intNy, this->ptrSlz->M_intNz, (int)3);
					 //writeAttributes(M_xdmf, "Emme", "Vector", "Cell", this->ptrSlz->M_numGlobalElements,3);
					 //writeAttributes(M_xdmf, "Heff", "Vector", "Cell", this->ptrSlz->M_numGlobalElements,3);
					 //writeAttributes(M_xdmf, "Hms", "Vector", "Cell", this->ptrSlz->M_numGlobalElements,3);
					 //writeAttributes(M_xdmf, "Hexch", "Vector", "Cell", this->ptrSlz->M_numGlobalElements,3);
					 //writeAttributes(M_xdmf, "Hext", "Vector", "Cell", this->ptrSlz->M_numGlobalElements, 3);
					 //if(M_withMean==1){
					//	 writeAttributes(M_xdmf, "MeanM", "Vector", "Grid",1,3);
					 //}
					 //if (M_withMat == 1){
					//	 writeStaticAttributes(M_xdmf, "Saturation", "Scalar", "Cell", this->ptrSlz->M_numGlobalElements, 1);
					//	 writeStaticAttributes(M_xdmf, "ExchLength", "Scalar", "Cell", this->ptrSlz->M_numGlobalElements, 1);
					//	 writeStaticAttributes(M_xdmf, "Alfa", "Scalar", "Cell", this->ptrSlz->M_numGlobalElements, 1);
					//	 writeStaticAttributes(M_xdmf, "Material", "Scalar", "Cell", this->ptrSlz->M_numGlobalElements, 1);
					//	 writeStaticAttributes(M_xdmf, "Anisotropy", "Scalar", "Cell", this->ptrSlz->M_numGlobalElements, 1);
					 //}
			
				         M_xdmf << "\n"
				             "    </Grid>\n\n";
			
				
				
				         // write closing lines
				         writeCloseLinesXdmf();
			     
		 }
	
		 // save position and write closing lines

    void writeXdmf::writeCloseLinesXdmf()
		 {
		     // save position
			     M_closingLinesPosition = M_xdmf.tellp();
		
			     // write closing lines
			     M_xdmf << M_closingLines;
		     M_xdmf.flush();
		
			 }
	void writeXdmf::removeCloseLinesXdmf()
		{
		    M_xdmf.seekp(M_closingLinesPosition);
		}

	void writeXdmf::writeTopology(std::ofstream& xdmf,int& MeshType)
	{
		std::string FEstring;

		switch (MeshType)
		{
		case 34:
			FEstring = "Tetrahedron";
			break;
		case 36:
			FEstring = "Hexahedron";
			break;
		case 23:
			FEstring = "Triangle";
			break;
		case 24:
			FEstring = "Quadrilateral";
			break;
		case 39:
			FEstring = "3DCORECTMESH";
		default:
			("FE not allowed in HDF5 Exporter");
		}

		xdmf << "      <Topology\n"
			<< "         Type=\""
			<< FEstring
			<< "\"\n"
			<< "         NumberOfElements=\""
			<< this->ptrMesh->numGlobalElements()
			<< "\"\n"
			<< "         BaseOffset=\""
			<< 0
			<< "\">\n"
			<< "         <DataStructure Format=\"HDF\"\n"
			<< "                        Dimensions=\""
			<< this->ptrMesh->meshDX() + 1
			<< " "
			<< this->ptrMesh->meshDY() + 1
			<< " "
			<< this->ptrMesh->meshDZ() + 1
			<< " "
			<< "\"\n" << " </Topology>\n";
	}

	void writeXdmf::writeStructuredTopology(std::ofstream& xdmf, int& MeshType)
	{
		std::string FEstring;

		switch (MeshType)
		{
		case 39:
			FEstring = "3DCORECTMESH";
		default:
			("FE not allowed in HDF5 Exporter");
		}

		xdmf << "      <Topology Type=\""	<< FEstring<< "\" Dimensions=\""<< this->ptrMesh->meshSizeX() + 1<< " "<< this->ptrMesh->meshSizeY() + 1	<< " "<< this->ptrMesh->meshSizeZ() + 1	<< "\"/>\n";
	}

	void writeXdmf::writeGeometry(std::ofstream& xdmf)
		 {
		
			     std::string postfix_string;
		
			     // see also in postProcess

			         postfix_string = "";
		
			
			     xdmf <<
			         "      <Geometry Type=\"ORIGIN_DXDYDZ\">\n" <<
			         "         <DataStructure Format=\"XML\"\n" <<
			         "                        Dimensions=\"3\"\n" <<
			         "                        DataType=\"Float\"\n" <<
			         "                        Precision=\"8\">\n" <<
			         "             " "0. 0. 0. ""\n" <<
			         "         </DataStructure>\n" <<
			         "         <DataStructure Format=\"HDF\"\n" <<
			         "                        Dimensions=\"1 3\"\n" <<
			         "                        DataType=\"Float\"\n" <<
			         "                        Precision=\"8\">\n" <<
			         "             " << M_H5FileName << ":/" << "DXDYDZ0/Val" << postfix_string << "\n" <<
			         "         </DataStructure>\n" <<
			         "      </Geometry>\n" <<
			         "\n";
		 }

	void writeXdmf::writeAttributes(std::ofstream& xdmf, std::string qtyName, std::string qtyType, std::string qtyCenter, int rowx, int rowy, int rowz, int column)
	{

		std::string postfix_string;

		// see also in postProcess

		postfix_string = "";
		xdmf <<
		"         <Attribute\n"<<
		"         		Type=\"" << qtyType << "\" \n" <<
		"         		Center=\""<<qtyCenter<<"\"\n" <<
		"		   		Name=\""<<qtyName<<"\">  \n"<<
		"         		<DataStructure Format=\"HDF\"\n"<<
		"                        Dimensions=\"" << rowx << " " << rowy << " " << rowz << " " << column << "\"\n" <<
		"                        DataType=\"Float\"\n"<<
		"                        Precision=\"8\">\n" <<
		"             	 " << M_H5FileName << ":/" << qtyName << this->ptrSlz->M_numTimeInstant << "/Val\n" <<
		"         	</DataStructure>\n"<<
		"         </Attribute>\n" <<
		"\n";
		
	}



	void writeXdmf::writeStaticAttributes(std::ofstream& xdmf, std::string qtyName, std::string qtyType, std::string qtyCenter, int rowx, int rowy, int rowz, int column)
	{

		std::string postfix_string;

		// see also in postProcess

		postfix_string = "";
		xdmf <<
			"         <Attribute\n" <<
			"         		Type=\"" << qtyType << "\" \n" <<
			"         		Center=\"" << qtyCenter << "\"\n" <<
			"		   		Name=\"" << qtyName << "\">  \n" <<
			"         		<DataStructure Format=\"HDF\"\n" <<
			"                        Dimensions=\"" << rowx << " " << rowy << " " << rowz << " " << column << "\"\n" <<
			"                        DataType=\"Float\"\n" <<
			"                        Precision=\"8\">\n" <<
			"             	 " << M_H5FileName << ":/" << qtyName << postfix_string << "\n" <<
			"         	</DataStructure>\n" <<
			"         </Attribute>\n" <<
			"\n";

	}
}
#endif